---
title: Midterm
author: RJ Cass
execute:
  echo: false
format: 
  pdf:
    include-in-header:
      text: |
        \usepackage{caption}
        \captionsetup{textfont={it}, font=small} 
        \usepackage{amsmath}
geometry: "margin=1in"
---

```{r initialize, warning=FALSE, message=FALSE}
# Initialize dataset
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(mgcv))
suppressPackageStartupMessages(library(splines))
suppressPackageStartupMessages(library(gratia))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(kableExtra))

set.seed(12345)

# Load data
lp_raw <- read.csv("LodgepoleInUintas.csv")

# Split data into the actual data rows, and the pred rows
pred_indeces <- which(is.na(lp_raw$Lodgepole))

pred <- lp_raw[pred_indeces, ]
lp <- lp_raw[-pred_indeces, ]
```

# Abstract
We analyzed data of the total Basal Area of trees in a plot, with corresponding environmental factors. We found that the factors that most influence tree growth are Elevation, Aspect, Longitude, and Latitude. We found that the combination of factors most conducive to tree growth was a Longitude and Latitude of -109.34, 40.99 (the maximum values for each), an elevation of 9755, and facing North (with slope not mattering). We created a GAM model to generate predcitions of total Basal Area for other plots not surveyed by the FIA, which are shown in @tbl-predicted_values in the Appendix. 


# 1: Introduction

### Context

We have a dataset representing the total basal size of all Lodgepole Pines within a plot, along with various environmental factors that may contribute to tree growth. We want to use these data to answer the following questions:

1\) How is lodgepole growth is affected by its environment?

2\) What environments are conducive to lodgepole growth?

3\) Given the environmental data for areas the FIA was not able to survey, what is the predicted basal area of the trees in that area?

### Data Exploration

Upon examining the data, we noticed the output variable (Basal Area) does not appear to be normally distributed (see @fig-normality_plots). As such, the normality assumption required for many modeling methods is not met and, if not addressed, generated models will not properly reflect the relationships between the input and output variables, and will have reduced predictive power. To account for this, we examined a log and a square root transform, and found that the square root transform better fits the normality assumptions. Thus, in models where normality is assumed, we will use the Square Root transform of Basal Area. 

```{r fig-normality_plots, fig.width = 8, fig.height = 2.5}
#| fig-cap: "Histograms of Basal Area (left) and its Log (middle) and Square Root (right) transforms. Note the skewness in the left and middle graphs."
par(mfrow = c(1, 3))
hist(lp$Lodgepole, breaks = 15, main = 'Basal Area', xlab = 'Basal Area')
hist(log(lp$Lodgepole), breaks = 15, main = 'Log of Basal Area', xlab = 'log(Basal Area)')
hist(sqrt(lp$Lodgepole), breaks = 15, main = 'Square Root of Basal Area', xlab = 'sqrt(Basal Area)')
par(mfrow = c(1,1))
```

We also identified that several of the factors appear either to be non-linear, or possibly non-significant in determining Basal Area. Shown in @fig-scatterplots are the scatter-plots of Basal Area plotted against each factor. 

```{r fig-scatterplots, fig.width=8, fig.height=4}
#| fig-cap: "Scatterplots of the square root of Basal Area vs. each explanatory factor. Note that Aspect and Elevation appear to be non-linear relationships."
par(mfrow = c(2, 3), mar = c(4, 4, 1, 3.5))
plot(lp$LON, sqrt(lp$Lodgepole), xlab = 'Longitude', ylab = 'sqrt(Basal Area)') # Probably linear, maybe exclude?
plot(lp$LAT, sqrt(lp$Lodgepole), xlab = 'Latitude', ylab = 'sqrt(Basal Area)') # Probably linear, maybe exclude?
plot(lp$Slope, sqrt(lp$Lodgepole), xlab = 'Slope', ylab = 'sqrt(Basal Area)') # Maybe non-linear. Variance much higher at lower slope
plot(lp$Aspect, sqrt(lp$Lodgepole), xlab = 'Aspect', ylab = 'sqrt(Basal Area)') # Seems to be U-shaped (makes sense as the start and finish are actually the same value)
plot(lp$ELEV, sqrt(lp$Lodgepole), xlab = 'Elevation', ylab = 'sqrt(Basal Area)') # weird normal shape, LOTS of variability in middle
par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1))
```


# 2: Methodology

### 2.1 Proposed Models

##### Model 1
For our second model we considered a Generalized Additive Model (GAM). To determine which variables to include, we fit an inital GAM to the square root of Basal Area. Reviewing the plots in @fig-scatterplots, we chose Longitude, Latitude, and Slope to be linear relationships. We chose to fit Elevation using a natural spline because it forces linearity outside the range of given data which will help with better predictive power for values outside our range. We chose to fit Aspect using a basis spline because Aspect is bounded between 0 and 360 so we do not need to worry about values outside that range. We then reviewed the p-values to see which factors were significant and found that with an $alpha = 0.5$, Slope was not significant so we removed it from the model. 

GAM models require the LINE assumptions of Linearity (in the case each variate is linear compared to the rest of the model), Independence, Normality, and Equal Variance. If these conditions are not met, the model will not accurately predict, nor represent the correct explanatory relatinships between values. 

This model will allow us to answer the research questions by identifying what combination of factors yields the highest Basal Areas, as well as provide predictions for plots outside of the provided data. 

```{r model_1}
model1 <- gam(sqrt(Lodgepole) ~ LON + LAT + bs(Aspect) + ns(ELEV, df = 3), data = lp, method = "REML")
```

##### Model 2

For our second model we created a LOESS (locally estimated scatterplot smoothing) model fitting. Given we found previously that Slope was not significant, and a LOESS model is normally limited to 4 factors due to increasing computational requirements with higher dimensionality, we chose to exclude Slope from this model as well. 

Loess models do not have any assumptions that need to be met. This model can be used to answer the research questions by identifying which combinations give the largest Basal Area, and by predciting for plots outside the measured values.

```{r model_2}
model2 <- loess(sqrt(Lodgepole) ~ LON + LAT + Aspect + ELEV, data = lp)
```

### 2.2 Model Evaluation and Selection
```{r LOOCV}
# LOOCV
# Setup values we want to explore over
loess_test_errors <- numeric(nrow(lp))
gam_test_errors <- numeric(nrow(lp))

# LOOCV: Leave One Out Cross Validation
# For LOOCV, we loop through each observation i as the test set. 
for(i in 1:nrow(lp)){
  train = lp[-i,]
  test = lp[i,]
  
  ### LOESS
  # fit loess with chosen span
  loocv_mod <- loess(sqrt(Lodgepole) ~ LON + LAT + Aspect + ELEV, data = lp)
  yhat <- predict(loocv_mod, newdata = test)
  loess_test_errors[i] <- test$Lodgepole - yhat
   

  ### GAM
  # gam will cv itself, but we want to compare OOS MSE
  loocv_mod <- gam(sqrt(Lodgepole) ~ LON + LAT + bs(Aspect) + ns(ELEV, df = 3), data = lp, method = "REML")
  yhat <- predict(loocv_mod, newdata = test)
  gam_test_errors[i] = test$Lodgepole - yhat
}

# Calculate the RMSE, as well as CI intervals
loess_loocv_rmse <- round(sqrt(mean(loess_test_errors^2)), 3)
loess_loocv_rmse_se <- round(qnorm(.975) * sqrt(sd(loess_test_errors)/length(lp)), 3)
gam_loocv_rmse <- round(sqrt(mean(gam_test_errors^2)), 3)
gam_loocv_rmse_se <- round(qnorm(.975) * sqrt(sd(gam_test_errors)/length(lp)), 3)

# Find In-Sample RMSEs
gam_yhat <- predict(model1, newdata = lp)
gam_in_rmse <- round(sqrt(mean((lp$Lodgepole - gam_yhat)^2)), 3)
loess_yhat <- predict(model2, newdata = lp)
loess_in_rmse <- round(sqrt(mean((lp$Lodgepole - loess_yhat)^2)), 3)
```

To compare the models we performed Leave-One-Out Cross Validation and calculated the RMSE of each model, as shown in @tbl-loocv. The RMSE values for the two models are very close, and their confidence intervals overlap. Thus, neither of the models appears to hae a signifianct advantage in predictive power. However, the GAM model is much more explainable due to being a direct transform of the explaining factors. Thus, we chose to use the GAM model to answer our research questions. 

| Model | LOOCV RMSE | 
| :---: | :--------: |
| GAM   | `r gam_loocv_rmse` $\pm$ `r gam_loocv_rmse_se`     |
| LOESS | `r loess_loocv_rmse` $\pm$ `r loess_loocv_rmse_se` |
: {#tbl-loocv}

The GAM model we are using follows this format:

```{=tex}
\begin{equation*}
    \begin{split}
        g(\mathbb{E}(\sqrt{Basal Area})) = \beta_0 + \beta_1 Longitude + \beta_2 Latitude + \sum_{k=1}^{3} \beta_k b_k (Aspect) + \sum_{k=1}^{3} \beta_k n_k(Elevation)
    \end{split}
\end{equation*}
```

As shown in @fig-normality_plots, we performed a transform on Basal Area to meet the normality assumptions. Independence is assumed (that one plot of trees does not impact another plot of trees). @fig-assumptions outlines the Linearity (left) and Equal Variance (right) assumptions. The left plot appears to have some shape to it, indicating that Linearity may not be a clear assumption. However, we believe it to be sufficient for this analysis. The variance of points in the line on the right plot appear equal, indicating the Equal Variance assumption is met.

```{r fig-assumptions, fig.width = 8, fig.height = 2}
#| fig-cap: "Left - residual plot, note the change in variance across the x-axis.  Right - fitted vs. actual values, note the variance appears equal over the fit"

# Save chosen model
chosen_model <- model1

# Plot the assumption plots (Linearity and Equal Variance)
lin <- residuals_linpred_plot(model1)
var <- observed_fitted_plot(model1)
grid.arrange(lin, var, nrow = 1)


# Resid plots of the LOESS model
# residuals_loess <- residuals(model2)
# fitted_values_loess <- fitted(model2)
# plot(sqrt(lp$Lodgepole), residuals_loess,
#       main = "Residuals of LOESS Fit vs. Predictor",
#       xlab = "Predictor Variable (x)",
#       ylab = "Residuals")
# abline(h = 0, col = "red", lty = 2) 
```

# 3: Results

The calculated coefficients for each term of the GAM model are provided in the @tbl-coefficients in the Appendix. As described previously, we found that all factors were signficant in determining Basal Area except for Slope. 

```{r}
lon_range <- seq(min(lp$LON), max(lp$LON), length.out = 20)
lat_range <- seq(min(lp$LAT), max(lp$LAT), length.out = 20)
slope_range <- c(1)
aspect_range <- seq(min(lp$Aspect), max(lp$Aspect), length.out = 100)
elev_range <- seq(min(lp$ELEV), max(lp$ELEV), length.out = 100)


full_range <- expand.grid(lon_range, lat_range, slope_range, aspect_range, elev_range)
colnames(full_range) <- c("LON", "LAT", "Slope", 'Aspect', 'ELEV')

full_range$yhat <- predict(chosen_model, newdata = full_range)
max <- full_range[full_range$yhat == max(full_range$yhat),]
max_lon <- round(max$LON, 2)
max_lat <- round(max$LAT, 2)
max_slope <- round(max$Slope, 2)
max_aspect <- round(max$Aspect, 2)
max_elev <- round(max$ELEV, 2)
```

We found that the conditions most conducive to tree growth are:

| Longitude | Latitude | Slope | Aspect | Elevation |
| :-------: | :------: | :---: | :----: | :-------: |
| `r max_lon` | `r max_lat` | `r max_slope` | `r max_aspect` | `r max_elev` |
: {#tbl-max_conditions}

``` {r fig-fit_plots, fig.width=8, fig.height=3.5}
#| fig-cap: "Plots showing the model fit of each variable. Each plot holds all other variables constant at their mean value. Because Slope was excluded from the model it is just flat."

# Adjust spacing around graphs to make them closer together
par(mfrow = c(2, 3), mar = c(4, 4, 1, 3.5))
# Plot features
for (col in head(colnames(lp), -1)) {
  # Make a sequence of points from min to max value of column
  plot_var = seq(min(lp[[col]]), max(lp[[col]]), length = 100)
  # Make temp table which drops the column of interest, leaving only the columns which should be constant
  temp <- lp[, -which(names(lp) == col)]

  # Create array of 'test' data where the other values are just the mean of the column
  if (col == "LON") {
    testdata = data.frame(LON = plot_var, LAT = mean(temp[, 1]), Slope = mean(temp[, 2]), Aspect = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "LAT") {
    testdata = data.frame(LAT = plot_var, LON = mean(temp[, 1]), Slope = mean(temp[, 2]), Aspect = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "Slope") {
    testdata = data.frame(Slope = plot_var, LON = mean(temp[, 1]), LAT = mean(temp[, 2]), Aspect = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "Aspect") {
    testdata = data.frame(Aspect = plot_var, LON = mean(temp[, 1]), LAT = mean(temp[, 2]), Slope = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "ELEV") {
    testdata = data.frame(ELEV = plot_var, LON = mean(temp[, 1]), LAT = mean(temp[, 2]), Slope = mean(temp[, 3]), Aspect = mean(temp[, 4]))
  }
  
  # Generate yhats for the data range
  predictions = predict(chosen_model, newdata = testdata, type = 'response', se = TRUE)

  df_preds = data.frame(testdata, predictions) %>%
    mutate(lower = fit - 1.96 * se.fit,
          upper = fit + 1.96 * se.fit)

  plot(lp[[col]], lp$Lodgepole, xlab = col, ylab = 'Basal Area', pch = 16)
  lines(plot_var, df_preds$fit^2, col = 'red', lwd = 2)
  lines(plot_var, df_preds$lower^2, col = 'blue', lty = 2, lwd = 2)
  lines(plot_var, df_preds$upper^2, col = 'blue', lty = 2, lwd = 2)
}
par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1))
```


``` {r fig-aspect_graph, fig.width=4, fig.height=4.5, warning = FALSE}
#| fig-cap: " Distribution of Basal Area in relation to cardinal direction (North, East,etc.). Note that the largest Basal Areas tend to be on Northern-facing slopes."
# Define the circle regions in degrees, then generate x/y values rotated since in data, 0 = North

deg <- seq(0, 360, by = .1)
rot_rad <- deg * pi/180 + pi/2
x <- cos(rot_rad)
y <- sin(rot_rad)
# Generate vector of test data, setting the other values to their means
testdata = data.frame(Aspect = deg, LON = mean(lp$LON), LAT = mean(lp$LAT), Slope = mean(lp$Slope), ELEV = mean(lp$ELEV))

# Generate yhats for the data range
predictions = predict(chosen_model, newdata = testdata, type = 'response', se = TRUE)
df_preds = data.frame(testdata, predictions)

# Define the color range
colors <- colorRampPalette(c("yellow", "red"))(length(unique(df_preds$fit^2)))
plot_colors <- colors[cut(df_preds$fit^2, breaks = length(colors))]

# Add the compass points
par(las = 1) # Set the labels to default rotation
plot(c(-1, 1), c(-1, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", bty = "n", main = "Basal Area by Cardinal Direction")
mtext("S", side = 1, line = 1, cex = 2)
mtext("N", side = 3, line = 0, cex = 2)
par(las = 2) # Forces labels to be perpendicular to axis
mtext("W", side = 2, line = 0, cex = 2)
mtext("E", side = 4, line = 0, cex = 2)
par(las = 1) # Returns labels to default rotation

for (i in 1:(length(x)-1)) {
  lines(c(x[i], x[i+1]), c(y[i], y[i+1]), col = plot_colors[i], lwd = 10)
}

# Set the position of the start and end of the legend line
legend_y <- 0 
legend_x_start <- -.5
legend_x_end <- .5
line_breaks = 100
# Define same solor breaks for the legend color pallete
colors_leg <- colorRampPalette(c("yellow", "red"))(line_breaks)
legend_colors <- colors[cut(1:line_breaks, breaks = length(colors))]
# Draw many small lines
for (i in 1:line_breaks) {
  lines(c(legend_x_start + i/line_breaks, legend_x_start + (i+1)/line_breaks),
        c(legend_y, legend_y),
        col = legend_colors[i], lwd = 10)
}
# Add min and max labels.
text(legend_x_start, legend_y-.1, labels = round(min(lp$Lodgepole), 2), pos = 1)
text(legend_x_end, legend_y-.1, labels = round(max(lp$Lodgepole), 2), pos = 1)
text(0, legend_y + .3, labels = "Basal Area", pos = 1) 

```



# 4: Conclusions


\newpage

# Appendix

Table showing the coefficients of the chosen model. It is important to remember that these coefficients come from a model of the square root of Basal Area.

```{r tbl-coefficients}
# Convert sparse coef matrix to a tidy tibble
coefs_tbl <- as.matrix(coef(chosen_model)) %>%
  as.data.frame() %>%
  rownames_to_column("Variable") %>%
  rename(Value = V1)

# Print nicely
print(coefs_tbl, row.names = FALSE)
```


```{r tbl-predicted_values, warning = FALSE}
pred$Lodgepole <- predict(chosen_model, pred)^2

kable(pred, longtable = TRUE) %>%
  kable_styling(latex_options = "repeat_header")
```
