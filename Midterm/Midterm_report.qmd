---
title: Midterm
author: RJ Cass
execute:
  echo: false
format: 
  pdf:
    include-in-header:
      text: |
        \usepackage{caption}
        \captionsetup{textfont={it}, font=small} 
        \usepackage{amsmath}
geometry: "margin=1in"
---

```{r initialize, warning=FALSE, message=FALSE}
# Initialize dataset
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(mgcv))
suppressPackageStartupMessages(library(splines))
suppressPackageStartupMessages(library(gratia))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(kableExtra))

set.seed(12345)

# Load data
lp_raw <- read.csv("LodgepoleInUintas.csv")

# Split data into the actual data rows, and the pred rows
pred_indeces <- which(is.na(lp_raw$Lodgepole))

pred <- lp_raw[pred_indeces, ]
lp <- lp_raw[-pred_indeces, ]
```

# Abstract
We analyzed data of the total Basal Area of trees in a plot and their corresponding environmental factors. We found that the factors that most influence tree growth are Elevation, Aspect, Longitude, and Latitude. We found that the combination of factors most conducive to tree growth was a Longitude and Latitude of -109.34, 40.99 (the maximum values for each), an elevation of 9755.8, and an aspect of 360 (facing North), with slope not being significant. We created a GAM model using these factors to generate predcitions of total Basal Area for other plots not surveyed by the FIA, which are shown in @tbl-predicted_values in the Appendix. 


# 1: Introduction

We have a dataset representing the total basal size of all Lodgepole Pines within a plot, along with various environmental factors that may contribute to tree growth. We want to use these data to answer the following questions:

1\) How is lodgepole growth is affected by its environment?

2\) What environments are conducive to lodgepole growth?

3\) Given the environmental data for areas the FIA was not able to survey, what is the predicted basal area of the trees in that area?

Examining the data, the output variable (Basal Area) does not appear to be normally distributed (see @fig-normality_plots). As such, the normality assumption required for many modeling methods is not met and, if not addressed, generated models will not properly reflect the relationships between the input and output variables, and will have reduced predictive power. To account for this, we examined a log and a square root transform, and found that the square root transform better fits the normality assumptions (also shown in @fig-normality_plots). Thus, in models where normality is assumed, we will use the square root transform of Basal Area. 

```{r fig-normality_plots, fig.width = 8, fig.height = 2.5}
#| fig-cap: "Histograms of Basal Area (left) and its Log (middle) and Square Root (right) transforms. Note the skewness in the left and middle graphs."
par(mfrow = c(1, 3))
hist(lp$Lodgepole, breaks = 15, main = 'Basal Area', xlab = 'Basal Area')
hist(log(lp$Lodgepole), breaks = 15, main = 'Log of Basal Area', xlab = 'log(Basal Area)')
hist(sqrt(lp$Lodgepole), breaks = 15, main = 'Square Root of Basal Area', xlab = 'sqrt(Basal Area)')
par(mfrow = c(1,1))
```

We also identified that several of the factors appear either to be non-linear, or possibly non-significant in determining Basal Area. Shown in @fig-scatterplots are the scatter-plots of Basal Area plotted against each factor. 

```{r fig-scatterplots, fig.width=8, fig.height=4}
#| fig-cap: "Scatterplots of the square root of Basal Area vs. each explanatory factor. Note that Aspect and Elevation appear to be non-linear relationships."
par(mfrow = c(2, 3), mar = c(4, 4, 1, 3.5))
plot(lp$LON, sqrt(lp$Lodgepole), xlab = 'Longitude', ylab = 'sqrt(Basal Area)') # Probably linear, maybe exclude?
plot(lp$LAT, sqrt(lp$Lodgepole), xlab = 'Latitude', ylab = 'sqrt(Basal Area)') # Probably linear, maybe exclude?
plot(lp$Slope, sqrt(lp$Lodgepole), xlab = 'Slope', ylab = 'sqrt(Basal Area)') # Maybe non-linear. Variance much higher at lower slope
plot(lp$Aspect, sqrt(lp$Lodgepole), xlab = 'Aspect', ylab = 'sqrt(Basal Area)') # Seems to be U-shaped (makes sense as the start and finish are actually the same value)
plot(lp$ELEV, sqrt(lp$Lodgepole), xlab = 'Elevation', ylab = 'sqrt(Basal Area)') # weird normal shape, LOTS of variability in middle
par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1))
```


# 2: Methodology

### 2.1 Proposed Models

##### Model 1
The first model considered was a Generalized Additive Model (GAM). To determine which variables to include we fit an inital GAM model using all factors to the square root of Basal Area. Reviewing the plots in @fig-scatterplots, we chose Longitude, Latitude, and Slope to be linear relationships. We chose to fit Elevation using a natural spline because it forces linearity outside the range of given data which will help with better predictive power for values outside our range. We chose to fit Aspect using a basis spline because Aspect is bounded between 0 and 360 so we do not need to worry about values outside that range. Reviewing the p-values, we found that with an $\alpha = .05$ Slope was not significant so we removed it from the model. 

GAM models require the LINE assumptions of Linearity (in the case each variate is linear compared to the rest of the model), Independence, Normality, and Equal Variance. If these conditions are not met, the model will not accurately predict, nor represent the correct explanatory relationships between values. This model will allow us to answer the research questions by identifying what combination of factors yields the highest Basal Area, as well as provide predictions for land plots outside of the measured values. 

```{r model_1}
model1 <- gam(sqrt(Lodgepole) ~ LON + LAT + bs(Aspect) + ns(ELEV, df = 3), data = lp, method = "REML")
```

##### Model 2

For our second model we created a LOESS (locally estimated scatterplot smoothing) model. Given a LOESS model is normally limited to 4 factors due to increased complexity with higher dimensionality, and we previously found that Slope was not significant, we chose to exclude Slope from this model as well. LOESS models do not have any assumptions that need to be met. This model can be used to answer the research questions by identifying which combinations give the largest Basal Area, and by predciting for land plots outside the measured values.

```{r model_2}
model2 <- loess(sqrt(Lodgepole) ~ LON + LAT + Aspect + ELEV, data = lp)
```

### 2.2 Model Evaluation and Selection
```{r LOOCV}
# LOOCV
# Setup values we want to explore over
loess_test_errors <- numeric(nrow(lp))
gam_test_errors <- numeric(nrow(lp))

# LOOCV: Leave One Out Cross Validation
# For LOOCV, we loop through each observation i as the test set. 
for(i in 1:nrow(lp)){
  train = lp[-i,]
  test = lp[i,]
  
  ### LOESS
  # fit loess with chosen span
  loocv_mod <- loess(sqrt(Lodgepole) ~ LON + LAT + Aspect + ELEV, data = lp)
  yhat <- predict(loocv_mod, newdata = test)
  loess_test_errors[i] <- test$Lodgepole - yhat
   

  ### GAM
  # gam will cv itself, but we want to compare OOS MSE
  loocv_mod <- gam(sqrt(Lodgepole) ~ LON + LAT + bs(Aspect) + ns(ELEV, df = 3), data = lp, method = "REML")
  yhat <- predict(loocv_mod, newdata = test)
  gam_test_errors[i] = test$Lodgepole - yhat
}

# Calculate the RMSE, as well as CI intervals
loess_loocv_rmse <- round(sqrt(mean(loess_test_errors^2)), 3)
loess_loocv_rmse_se <- round(qnorm(.975) * sqrt(sd(loess_test_errors)/length(lp)), 3)
gam_loocv_rmse <- round(sqrt(mean(gam_test_errors^2)), 3)
gam_loocv_rmse_se <- round(qnorm(.975) * sqrt(sd(gam_test_errors)/length(lp)), 3)

# Find In-Sample RMSEs
gam_yhat <- predict(model1, newdata = lp)
gam_in_rmse <- round(sqrt(mean((lp$Lodgepole - gam_yhat)^2)), 3)
loess_yhat <- predict(model2, newdata = lp)
loess_in_rmse <- round(sqrt(mean((lp$Lodgepole - loess_yhat)^2)), 3)
gam_r2 <- round(summary(model1)$r.sq, 3)
```

To compare the models we performed Leave-One-Out Cross Validation (LOOCV) and calculated the RMSE of each model, as shown in @tbl-loocv. The GAM model yielded an In Sample $R^2$ value of `r gam_r2`. The LOESS model, being non-parametric, does not give a standard $R^2$ value so we will compare the models using the LOOCV RMSE. The RMSE of the two models are very close and their confidence intervals overlap. However, the GAM model is much more interpretable due to being a direct transform of the explaining factors. Thus, we will use the GAM model to answer our research questions. 

| Model | LOOCV RMSE | 
| :---: | :--------: |
| GAM   | `r gam_loocv_rmse` $\pm$ `r gam_loocv_rmse_se`     |
| LOESS | `r loess_loocv_rmse` $\pm$ `r loess_loocv_rmse_se` |
: {#tbl-loocv}

The GAM model follows this format with the calculated $\beta$ values shown in @tbl-coefficients in the Appendix:

```{=tex}
\begin{equation*}
    \begin{split}
        g(\mathbb{E}(\sqrt{Basal Area})) = \beta_0 + \beta_1 Longitude + \beta_2 Latitude + \sum_{k=1}^{3} \beta_k b_k (Aspect) + \sum_{k=1}^{3} \beta_k n_k(Elevation)
    \end{split}
\end{equation*}
```

As shown in @fig-normality_plots, we performed a square root transform on Basal Area to meet the normality assumptions. Independence (that one plot of trees does not impact another plot of trees) is assumed . @fig-assumptions outlines the Linearity (left) and Equal Variance (right) assumptions. The left plot appears to have some shape/pattern to it, indicating that Linearity may not be a clear assumption. However, we believe it to be sufficient for this analysis. The variance of points in the line on the right plot appear equal, indicating the Equal Variance assumption is met.

```{r fig-assumptions, fig.width = 8, fig.height = 2}
#| fig-cap: "Left - residual plot, note the change in variance across the x-axis.  Right - fitted vs. actual values, note the variance appears equal over the fit"

# Save chosen model
chosen_model <- model1

# Plot the assumption plots (Linearity and Equal Variance)
lin <- residuals_linpred_plot(model1)
var <- observed_fitted_plot(model1)
grid.arrange(lin, var, nrow = 1)


# Resid plots of the LOESS model
# residuals_loess <- residuals(model2)
# fitted_values_loess <- fitted(model2)
# plot(sqrt(lp$Lodgepole), residuals_loess,
#       main = "Residuals of LOESS Fit vs. Predictor",
#       xlab = "Predictor Variable (x)",
#       ylab = "Residuals")
# abline(h = 0, col = "red", lty = 2) 
```


# 3: Results

We can use the GAM model identified previously to answer our research questions:

1. The significant factors in determining Basal Area using the data provided are Longitude, Latitude, Aspect, and Elevation. Provided in @fig-fit_plots are the plotted model fits of each significant explanatory value. Because Aspect is a measure of degrees from North, it is a little easier to understand when represented in terms of cardinal directions, as shown in the same plot.

``` {r fig-fit_plots, fig.width=8, fig.height=4, warning = FALSE}
#| fig-cap: "Plots showing the model fit of each variable. Each plot holds all other variables constant at their mean value. Because Slope was excluded from the model it is just flat so we excluded it here. The last plot shows the fitted Aspect in terms of cardinal direction."

# Adjust spacing around graphs to make them closer together
par(mfrow = c(2, 3), mar = c(4, 4, 1, 2))
# Plot features
cols <- c('LON', 'LAT', 'ELEV', 'Aspect')
for (col in cols) {
  # Make a sequence of points from min to max value of column
  plot_var = seq(min(lp[[col]]), max(lp[[col]]), length = 100)
  # Make temp table which drops the column of interest, leaving only the columns which should be constant
  temp <- lp[, -which(names(lp) == col)]

  # Create array of 'test' data where the other values are just the mean of the column
  if (col == "LON") {
    testdata = data.frame(LON = plot_var, LAT = mean(temp[, 1]), Slope = mean(temp[, 2]), Aspect = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "LAT") {
    testdata = data.frame(LAT = plot_var, LON = mean(temp[, 1]), Slope = mean(temp[, 2]), Aspect = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "Slope") {
    next
    #testdata = data.frame(Slope = plot_var, LON = mean(temp[, 1]), LAT = mean(temp[, 2]), Aspect = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "Aspect") {
    testdata = data.frame(Aspect = plot_var, LON = mean(temp[, 1]), LAT = mean(temp[, 2]), Slope = mean(temp[, 3]), ELEV = mean(temp[, 4]))
  } else if (col == "ELEV") {
    testdata = data.frame(ELEV = plot_var, LON = mean(temp[, 1]), LAT = mean(temp[, 2]), Slope = mean(temp[, 3]), Aspect = mean(temp[, 4]))
  }
  
  # Generate yhats for the data range
  predictions = predict(chosen_model, newdata = testdata, type = 'response', se = TRUE)

  df_preds = data.frame(testdata, predictions) %>%
    mutate(lower = fit - 1.96 * se.fit,
          upper = fit + 1.96 * se.fit)

  plot(lp[[col]], lp$Lodgepole, xlab = col, ylab = 'Basal Area', pch = 16)
  lines(plot_var, df_preds$fit^2, col = 'red', lwd = 2)
  lines(plot_var, df_preds$lower^2, col = 'blue', lty = 2, lwd = 2)
  lines(plot_var, df_preds$upper^2, col = 'blue', lty = 2, lwd = 2)
}

####### ASPECT GRAPH
deg <- seq(0, 360, by = .1)
rot_rad <- deg * pi/180 + pi/2
x <- cos(rot_rad)
y <- sin(rot_rad)
# Generate vector of test data, setting the other values to their means
testdata = data.frame(Aspect = deg, LON = mean(lp$LON), LAT = mean(lp$LAT), Slope = mean(lp$Slope), ELEV = mean(lp$ELEV))

# Generate yhats for the data range
predictions = predict(chosen_model, newdata = testdata, type = 'response', se = TRUE)
df_preds = data.frame(testdata, predictions)

# Define the color range
colors <- colorRampPalette(c("yellow", "red"))(length(unique(df_preds$fit^2)))
plot_colors <- colors[cut(df_preds$fit^2, breaks = length(colors))]

par(mar = c(4, 4.1, 1, 5.1))
# Add the compass points
par(las = 1) # Set the labels to default rotation
plot(c(-1, 1), c(-1, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", bty = "n")
mtext("S", side = 1, line = 1, cex = 1)
mtext("N", side = 3, line = 0, cex = 1)
par(las = 2) # Forces labels to be perpendicular to axis
mtext("W", side = 2, line = 0, cex = 1)
mtext("E", side = 4, line = 0, cex = 1)
par(las = 1) # Returns labels to default rotation

for (i in 1:(length(x)-1)) {
  lines(c(x[i], x[i+1]), c(y[i], y[i+1]), col = plot_colors[i], lwd = 10)
}

# Set the position of the start and end of the legend line
legend_y <- 0 
legend_x_start <- -.5
legend_x_end <- .5
line_breaks = 100
# Define same solor breaks for the legend color pallete
colors_leg <- colorRampPalette(c("yellow", "red"))(line_breaks)
legend_colors <- colors[cut(1:line_breaks, breaks = length(colors))]
# Draw many small lines
for (i in 1:line_breaks) {
  lines(c(legend_x_start + i/line_breaks, legend_x_start + (i+1)/line_breaks),
        c(legend_y, legend_y),
        col = legend_colors[i], lwd = 10)
}
# Add min and max labels.
text(legend_x_start, legend_y-.1, labels = round(min(lp$Lodgepole), 2), pos = 1)
text(legend_x_end, legend_y-.1, labels = round(max(lp$Lodgepole), 2), pos = 1)
text(0, legend_y + .4, labels = "Basal Area", pos = 1) 
par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1))
```

2. Using our constructed model we evaluated points over the full range of provided data and identified the conditions most conducive to tree growth. These values are shown in @tbl-optimal_conditions.

```{r tbl-optimal_conditions}
lon_range <- seq(min(lp$LON), max(lp$LON), length.out = 20)
lat_range <- seq(min(lp$LAT), max(lp$LAT), length.out = 20)
slope_range <- c(1)
aspect_range <- seq(min(lp$Aspect), max(lp$Aspect), length.out = 100)
elev_range <- seq(min(lp$ELEV), max(lp$ELEV), length.out = 100)


full_range <- expand.grid(lon_range, lat_range, slope_range, aspect_range, elev_range)
colnames(full_range) <- c("LON", "LAT", "Slope", 'Aspect', 'ELEV')

full_range$yhat <- predict(chosen_model, newdata = full_range)
max <- full_range[full_range$yhat == max(full_range$yhat),]
max_lon <- round(max$LON, 2)
max_lat <- round(max$LAT, 2)
max_slope <- round(max$Slope, 2)
max_aspect <- round(max$Aspect, 2)
max_elev <- round(max$ELEV, 2)

table <- c(max_lon, max_lat, max_slope, max_aspect, max_elev) |> data.frame() |> t()
colnames(table) <- c('Longitude', 'Latitude', 'Slope', 'Aspect', 'Eelevation')
kable(table, row.names = FALSE)
```

3. We also used the model to generate predicted values for plots of land not surveyed by the FIA. These values are provided in @tbl-predicted_values in the Appendix. 

# 4: Conclusions
We used the Lodgepole data to understand the relationship between various environmental factors and the Basal Area of plots of Lodegpole pines. Of the explanatory factors, we identified that Slope was not significant in determining Basal Area so we created a GAM model consisting of Longitude, Latitude, Aspect, and Elevation as related to the square root of Basal Area. We used this model to identify that the conditions most conducive to Lodgepole growth are a Longitude and Latitude of (`r max_lon`, `r max_lat`), an Aspect of `r max_aspect` (facing North), and an Elevation of `r max_elev` (with Slope not being significant). We also used the model to generate predicted values for land plots not visited by the FIA, as shown in @tbl-predicted_values.

We believe that the significance of Latitude and Longitude is likely driven due to other factors such as an interaction with elevation, or changing temperatures as you move in a certain direction, etc. A future step for this analysis would be to identify any interaction among explanatory factors. We also suggest further study into other environmental factors that would impact tree growth, such as distance to the nearest water source.


\newpage

# Appendix

```{r tbl-coefficients}
#| tbl-cap: "Table showing the coefficients of the chosen model. It is important to remember that these coefficients come from a model of the square root of Basal Area."

# Convert sparse coef matrix to a tidy tibble
coefs_tbl <- as.matrix(parameters::model_parameters(chosen_model)) %>%
  as.data.frame()
coefs_tbl <- coefs_tbl[, c(1, 2, 5, 6)]

# Print nicely
kable(coefs_tbl, row.names = FALSE)
```


```{r tbl-predicted_values, warning = FALSE}
pred$Lodgepole <- predict(chosen_model, pred)^2

kable(pred, longtable = TRUE, row.names = FALSE) %>%
  kable_styling(latex_options = "repeat_header")
```







